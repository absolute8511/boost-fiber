[/
  (C) Copyright 2007-8 Anthony Williams.
  (C) Copyright 2013 Oliver Kowalke.
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]

[section:mutex_types Mutex Types]

[class_heading mutex]

        #include <boost/fiber/mutex.hpp>
        
        class mutex
        {
        public:
            mutex();
            ~mutex();
        
            mutex( mutex const& other) = delete;
            mutex & operator=( mutex const& other) = delete;
        
            void lock();
            bool try_lock();
            void unlock();
        };

__mutex__ provides an exclusive-ownership mutex. At most one fiber can own the
lock on a given instance of __mutex__ at any time. Multiple concurrent calls to
__lock__, __try_lock__ and __unlock__ shall be permitted.

Any fiber blocked in __lock__ is suspended in the scheduler until the owning
fiber releases the lock by calling __unlock__.


[class_heading timed_mutex]

        #include <boost/fiber/timed_mutex.hpp>

        class timed_mutex : private boost::noncopyable
        {
        public:
            timed_mutex();
            ~timed_mutex();

            timed_mutex( timed_mutex const& other) = delete;
            timed_mutex & operator=( timed_mutex const& other) = delete;

            void lock();
            void unlock();
            bool try_lock();

            template< typename Clock, typename Duration >
            bool try_lock_until( chrono::time_point< Clock, Duration > const& timeout_time)
            template< typename Rep, typename Period >
            bool try_lock_for( chrono::duration< Rep, Period > const& timeout_duration)
        };

__timed_mutex__ provides an exclusive-ownership mutex. At most one fiber can own
the lock on a given instance of __timed_mutex__ at any time. Multiple concurrent
calls to __lock__, __try_lock__, __try_lock_until__, __try_lock_for__ and
__unlock__ shall be permitted.


[class_heading recursive_mutex]

        #include <boost/fiber/recursive_mutex.hpp>

        class recursive_mutex : private boost::noncopyable
        {
        public:
            recursive_mutex();
            ~recursive_mutex();

            recursive_mutex( recursive_mutex const& other) = delete;
            recursive_mutex & operator=( recursive_mutex const& other) = delete;

            void lock();
            bool try_lock() noexcept;
            void unlock();
        };

__recursive_mutex__ provides an exclusive-ownership recursive mutex. At most one
fiber can own the lock on a given instance of __recursive_mutex__ at any time.
Multiple concurrent calls to __lock__, __try_lock__ and __unlock__ shall be
permitted. A fiber that already has exclusive ownership of a given
__recursive_mutex__ instance can call __lock__ or __try_lock__ to acquire an
additional level of ownership of the mutex. __unlock__ must be called once for
each level of ownership acquired by a single fiber before ownership can be
acquired by another fiber.


[class_heading recursive_timed_mutex]

        #include <boost/fiber/recursive_timed_mutex.hpp>

        class recursive_timed_mutex : private boost::noncopyable
        {
        public:
            recursive_timed_mutex();
            ~recursive_timed_mutex();

            recursive_timed_mutex( recursive_timed_mutex const& other) = delete;
            recursive_timed_mutex & operator=( recursive_timed_mutex const& other) = delete;

            void lock();
            bool try_lock() noexcept;
            void unlock();

            template< typename Clock, typename Duration >
            bool try_lock_until( chrono::time_point< Clock, Duration > const& timeout_time)
            template< typename Rep, typename Period >
            bool try_lock_for( chrono::duration< Rep, Period > const& timeout_duration)
        };

__recursive_timed_mutex__ provides an exclusive-ownership recursive mutex. At
most one fiber can own the lock on a given instance of
__recursive_timed_mutex__ at any time. Multiple concurrent calls to __lock__,
__try_lock__, __try_lock_for__, __try_lock_until__ and __unlock__ shall be
permitted. A fiber that already has exclusive ownership of a given
__recursive_timed_mutex__ instance can call __lock__, __try_lock__,
__try_lock_for__ or __try_lock_until__ to acquire an additional level of
ownership of the mutex. __unlock__ must be called once for each level of
ownership acquired by a single fiber before ownership can be acquired by another
fiber.


[endsect]
