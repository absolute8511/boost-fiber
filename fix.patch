commit 37eb5a46f34aee1a3e10348922b49e3f47779847
Author: Vincent Lee <vincent.lee@b5m.com>
Date:   Thu Sep 11 16:35:50 2014 +0800

    fix optimize the fiber schedule

diff --git a/include/boost/fiber/detail/fifo.hpp b/include/boost/fiber/detail/fifo.hpp
index 76eec70..e4185c8 100644
--- a/include/boost/fiber/detail/fifo.hpp
+++ b/include/boost/fiber/detail/fifo.hpp
@@ -45,6 +45,11 @@ public:
 
         if ( empty() )
             head_ = tail_ = item;
+        else if (head_ == item)
+        {
+            // avoid cycle
+            return;
+        }
         else
         {
             tail_->next( item);
diff --git a/include/boost/fiber/detail/waiting_queue.hpp b/include/boost/fiber/detail/waiting_queue.hpp
index 1ae7351..a7d333b 100644
--- a/include/boost/fiber/detail/waiting_queue.hpp
+++ b/include/boost/fiber/detail/waiting_queue.hpp
@@ -43,18 +43,21 @@ public:
         BOOST_ASSERT( 0 == item->next() );
         BOOST_ASSERT( 0 == item->prev() );
 
+        if (item->head() != NULL)
+        {
+            return;
+        }
+
+        item->attach_queue(&head_, &tail_);
         if ( empty() )
             head_ = tail_ = item;
+        else if (head_ == item)
+        {
+            // avoid cycle
+            return;
+        }
         else
         {
-            worker_fiber * f = head_, * prev = 0;
-            if (item->time_point() == (clock_type::time_point::max)())
-            {
-                tail_->next(item);
-                item->prev(tail_);
-                tail_ = item;
-                return;
-            }
             if (item->is_ready())
             {
                 item->next(head_);
@@ -62,10 +65,18 @@ public:
                 head_ = item;
                 return;
             }
+            if (item->time_point() == (clock_type::time_point::max)())
+            {
+                tail_->next(item);
+                item->prev(tail_);
+                tail_ = item;
+                return;
+            }
+            worker_fiber * f = head_, * prev = 0;
             do
             {
                 worker_fiber * nxt = f->next();
-                if ( item->time_point() <= f->time_point() )
+                if ( (!f->is_ready()) && item->time_point() <= f->time_point() )
                 {
                     if ( head_ == f)
                     {
@@ -113,43 +124,35 @@ public:
     template< typename SchedAlgo>
     void move_to_run( SchedAlgo * sched_algo, detail::worker_fiber* f)
     {
+        // this function can be called in any thread, so the head_/tail_ can not be used.
         BOOST_ASSERT(!f->is_running());
-        if (f->next() == NULL && f->prev() == NULL && f != head_)
+        if (f->prev() == NULL)
         {
-            // not a waiting fiber
+            // head of waiting queue no need move.
         }
         else
         {
-            BOOST_ASSERT(!(f->prev() == NULL && f != head_));
-            BOOST_ASSERT(!(f->next() == NULL && f != tail_));
-            if (f == head_)
+            if (f->head() == NULL)
             {
-                head_ = f->next();
-                if (0 == head_)
-                    tail_ = 0;
-                else
-                {
-                    head_->prev(0);
-                }
+                // not in any waiting queue.
+                return;
+            }
+            // moving f to the head of its waiting queue so that it can be awakened first.
+            if (0 == f->next())
+            {
+                *(f->tail()) = f->prev();
             }
             else
             {
-                if (0 == f->next())
-                {
-                    BOOST_ASSERT(tail_ == f);
-                    tail_ = f->prev();
-                }
-                else
-                {
-                    f->next()->prev(f->prev());
-                }
-                f->prev()->next(f->next());
+                f->next()->prev(f->prev());
             }
-            f->next_reset();
+            f->prev()->next(f->next());
+
+            f->next(*(f->head()));
             f->prev_reset();
-            f->time_point_reset();
+            (*(f->head()))->prev(f);
+            *(f->head()) = f;
         }
-        sched_algo->awakened(f);
     }
 
     template< typename SchedAlgo, typename Fn >
@@ -164,6 +167,22 @@ public:
             worker_fiber * nxt = f->next();
             if ( fn( f, now) )
             {
+                // the f has been moved to head of queue.
+                BOOST_ASSERT(head_ == f);
+                head_ = f->next();
+                if (0 == head_)
+                {
+                    tail_ = 0;
+                }
+                else
+                {
+                    head_->prev(0);
+                }
+                f->next_reset();
+                f->prev_reset();
+                f->detach_queue();
+                f->time_point_reset();
+                sched_algo->awakened(f);
             }
             else
             {
diff --git a/include/boost/fiber/detail/worker_fiber.hpp b/include/boost/fiber/detail/worker_fiber.hpp
index b2a8cf0..4b51ed8 100644
--- a/include/boost/fiber/detail/worker_fiber.hpp
+++ b/include/boost/fiber/detail/worker_fiber.hpp
@@ -98,6 +98,8 @@ private:
     exception_ptr                   except_;
     spinlock                        splk_;
     std::vector< worker_fiber * >   waiting_;
+    worker_fiber                **  phead_;
+    worker_fiber                **  ptail_;
 
 public:
     worker_fiber( coro_t::yield_type *);
@@ -213,6 +215,28 @@ public:
         BOOST_ASSERT( is_running() ); // set by the scheduler-algorithm
     }
 
+    void attach_queue(worker_fiber** h, worker_fiber** t)
+    {
+        phead_ = h;
+        ptail_ = t;
+    }
+
+    void detach_queue()
+    {
+        phead_ = NULL;
+        ptail_ = NULL;
+    }
+
+    worker_fiber ** head()
+    {
+        return phead_;
+    }
+
+    worker_fiber ** tail()
+    {
+        return ptail_;
+    }
+
     worker_fiber * prev() const
     { return prev_; }
 
diff --git a/src/detail/worker_fiber.cpp b/src/detail/worker_fiber.cpp
index 3516eef..a654658 100644
--- a/src/detail/worker_fiber.cpp
+++ b/src/detail/worker_fiber.cpp
@@ -37,7 +37,9 @@ worker_fiber::worker_fiber( coro_t::yield_type * callee) :
     flags_( 0),
     priority_( 0),
     except_(),
-    waiting_()
+    waiting_(),
+    phead_(0),
+    ptail_(0)
 { BOOST_ASSERT( callee_); }
 
 worker_fiber::~worker_fiber()
diff --git a/src/fiber_manager.cpp b/src/fiber_manager.cpp
index 40379b8..1898926 100644
--- a/src/fiber_manager.cpp
+++ b/src/fiber_manager.cpp
@@ -110,7 +110,7 @@ fiber_manager::spawn( detail::worker_fiber * f)
     BOOST_ASSERT( f);
     BOOST_ASSERT( f->is_ready() );
 
-    //sched_algo_->awakened( f);
+    sched_algo_->awakened( f);
 }
 
 void
@@ -128,19 +128,6 @@ fiber_manager::run()
         if ( f)
         {
             BOOST_ASSERT_MSG( f->is_ready(), "fiber with invalid state in ready-queue");
-            // optimize the fiber schedule:
-            // if there is a fiber different from current active fiber,
-            // we should resume it first.
-            //bool is_self = (active_fiber_ == f);
-            //while (active_fiber_ == f)
-            //{
-            //    f = sched_algo_->pick_next();
-            //}
-            //if (is_self && f != NULL)
-            //    sched_algo_->awakened(active_fiber_);
-            //if (f == NULL)
-            //    f = active_fiber_;
-
             resume_( f);
             return;
         }
@@ -196,7 +183,7 @@ fiber_manager::yield()
     // set active fiber to state_waiting
     active_fiber_->set_ready();
     // push active fiber to scheduler-algo
-    // wqueue_.push(active_fiber_);
+    wqueue_.push(active_fiber_);
     active_fiber_->suspend();
     //sched_algo_->awakened( active_fiber_);
     // run next fiber
